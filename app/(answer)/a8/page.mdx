import Counter from "@/components/posts/8/Counter";

## 정답: 알파벳 `A`, `B`, `C`, `D`, `D`가 보인다.

<Counter />

### `key`에 `index`를 넣을 경우 의도치 않은 동작이 발생할 수 있다.

---

커밋 단계에서 리액트는 이전 상태와 다음 상태를 관찰한 뒤 변화가 있을 때만 DOM 노드를 변경한다고 했다. 이를테면 다음과 같다.

```html showLineNumbers
//before
<ul>
  <li>1</li>
  <li>2</li>
</ul>

//after
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
```

위와 같이 `<ul>` 태그 안에 세 번째 `<li>` 노드가 생긴 상황을 생각하자. 리액트는 두 리스트를 비교하여 어떤 변화가 생겼는지 파악한다.

1.  `<ul>` 태그의 첫 번째 자식은 동일하다. 아무 일도 일어나지 않는다.
2.  `<ul>` 태그의 두 번째 자식은 동일하다. 아무 일도 일어나지 않는다.
3.  그런데 `<ul>` 태그에 원래 없던 세 번째 자식이 추가 되었다. 리액트는 DOM에 해당 요소를 추가한다.

이렇게 최소한의 DOM 변경을 통해 브라우저의 연산을 줄일 수 있다. 그런데, 만약 마지막이 아닌 첫 번째 자리에 새로운 원소가 생기면 어떻게 될까?

```html showLineNumbers
//before
<ul>
  <li>1</li>
  <li>2</li>
</ul>

//after
<ul>
  <li>3</li>
  <li>1</li>
  <li>2</li>
</ul>
```

1.  `<ul>` 태그의 첫 번째 자식은 내용이 바뀌었다 (`1` → `3`). DOM에 업데이트가 일어난다.
2.  `<ul>` 태그의 두 번째 자식은 내용이 바뀌었다 (`2` → `1`). DOM에 업데이트가 일어난다.
3.  그런데 `<ul>` 태그에 원래 없던 세 번째 자식이 추가 되었다. 리액트는 DOM에 해당 요소를 추가한다.

결국 리액트는 모든 컴포넌트를 DOM에서 업데이트하게 되며, 이는 엄연한 낭비이다. 리액트에게 어떤 요소가 동일한 것인지를 알려줄 수는 없을까? 이때 사용할 수 있는 것이 `key` 속성이다.

```html showLineNumbers
//before
<li key="1">1</li>
<li key="2">2</li>

//after
<li key="3">3</li>
<li key="1">1</li>
<li key="2">2</li>
```

위와 같이 코드를 작성하게 되면, 리액트는 자동으로

그러면 1과 2는 리렌더링되지 않고 0만 추가되는 것을 알 수 있따.

그런데, 왜 index를 key로 사용하면 안되는 걸까? 왜냐하면 리액트는 key가 변하지않으면 상태가 변하지 않는다고 판단하기 때문이다. 이번 문제의 코드가 딱 그렇다. 앞에 원소가 추가되었지만 상태는 여전하다. 만약 이를 해결하고 싶다면, 다음과 같이 unique한 key를 제공해주면 된다. 그러면 잘 작동하는 것을 볼 수 있다.

---

### 참고자료

-
